#include "../Console.vhl"
#include "../ExceptionHandler.vhl"

#include "Allocator.vhl"

#include "OutOfMemoryException.vhl"
#include "BlockNotMappedException.vhl"

public class RawAllocatorBlockData
{
	private uint m_BlockLength;
	private uint m_IsFree;
	public static RawAllocatorBlockData(uint length, uint free)
	{	
		this.m_BlockLength = length;
		this.m_IsFree = free;
	}

	public uint GetBlockLength()
	{
		uint v = this.m_BlockLength;

		return v;
	}

	public void SetData(uint isFree, uint len)
	{
		this.m_IsFree = isFree;
		this.m_BlockLength = len;
	}

	public void SetFree(uint isFree)
	{
		this.m_IsFree = isFree;
	}

	public uint IsFree()
	{
		uint v = this.m_IsFree;
		return v;
	}
}


public class RawAllocator : Allocator
{
	private uint m_MemoryStart;
	private uint m_MemoryLength;
	private uint m_OptimizationLevel;

	public static RawAllocator(uint memoryStart, uint memoryLength)
	{
		this.m_MemoryStart = memoryStart;
		this.m_MemoryLength = memoryLength;
		this.CreateBlock(memoryStart, memoryLength-size_of(RawAllocatorBlockData), 1);
		this.m_OptimizationLevel = 0;
	}

	private uint CreateBlock(uint thisPtr, uint len, uint free)
	{
		return RawAllocatorBlockData.new(thisPtr, len, free);
	}


	public void SetOptimizationLevel(uint level)
	{
		this.m_OptimizationLevel = level;
	}

	private uint GetRawBlock(uint current)
	{
		return current + size_of(RawAllocatorBlockData);
	}


	private uint GetDataFromBlock(uint blockPtr)
	{
		return blockPtr - size_of(RawAllocatorBlockData);
	}


	private uint GetNext(uint current)
	{
		RawAllocatorBlockData data = current;
		uint size = data.GetBlockLength();
		size += size_of(RawAllocatorBlockData);
		size += current;
		return size;
	}

	private uint FindFree(uint current, uint minSize)
	{
		RawAllocatorBlockData data = current;
		if(data.IsFree() && data.GetBlockLength() >= minSize)
		{
			return current;
		}

		uint offset = this.GetRawBlock(current);
		offset += data.GetBlockLength();
		return this.FindFree(offset, minSize);
	}

	public override uint Allocate(uint size)
	{
		uint start = this.m_MemoryStart;
		uint next = this.FindFree(start, size);
		if(next) //Found a Free Block, reusing..
		{
			uint ptr = this.GetRawBlock(next); //Get Offset to the Actual Memory Block

			RawAllocatorBlockData data = next;
			uint actualSize = data.GetBlockLength();

			if(size < actualSize) //Block is to big, split it
			{
				data.SetData(0, size);

				RawAllocatorBlockData nextData = this.GetNext(next);

				uint blockLength = actualSize - size + size_of(RawAllocatorBlockData);

				nextData.SetData(1, blockLength);
			}

			return ptr;
		}
		ExceptionHandler.Throw(OutOfMemoryException());
	}

	public override uint Free(uint ptr)
	{
		RawAllocatorBlockData data = this.GetDataFromBlock(ptr);

		if(data.IsFree())
		{
			ExceptionHandler.Throw(BlockNotMappedException());
		}

		data.SetFree(1);

		this.OptimizeBlocks(); //Merge free Blocks
	}

	public void WriteDebugData()
	{
		string s_TableTitle = "Allocation Table: [Index, P = Pointer, S = Size, F = IsFree]";
		Console.WriteLine(&s_TableTitle, size_of(s_TableTitle));

		uint len = this.m_MemoryLength;
		uint max = this.m_MemoryStart;
		max += len;

		uint ptr = this.m_MemoryStart;

		uint cout = 0xFFFF1001;

		uint count = 0;

		while(ptr < max)
		{
			RawAllocatorBlockData data = ptr;

			Console.WriteNumber(count);
			Console.WriteChar('\t');
			Console.WriteChar('P');
			Console.WriteChar(':');
			Console.WriteNumber(ptr);
			Console.WriteChar('\t');
			Console.WriteChar('S');
			Console.WriteChar(':');
			Console.WriteNumber(data.GetBlockLength());
			Console.WriteChar('\t');
			Console.WriteChar('F');
			Console.WriteChar(':');
			Console.WriteNumberLine(data.IsFree());

			ptr = this.GetNext(data);
			count++;
		}
		Console.WriteChar('\n');
	}


	private void OptimizeBlocks()
	{
		uint optLevel = this.m_OptimizationLevel;
		if(!optLevel)
		{
			return;
		}
		uint len = this.m_MemoryLength;
		uint max = this.m_MemoryStart;
		max += len;

		uint ptr = this.m_MemoryStart;

		uint last = 0;

		uint optimized = 0;

		while(ptr < max)
		{
			RawAllocatorBlockData data = ptr;

			if(last)
			{
				RawAllocatorBlockData lastData = last;

				if(lastData.IsFree() && data.IsFree())
				{
					lastData.SetData(1,  //Set Free
						lastData.GetBlockLength() + //Current Size
						data.GetBlockLength() +
						size_of(RawAllocatorBlockData)); //Offset to acount for the now unused Data Structure
					optimized = 1;
				}
			}
			last = ptr;
			ptr = this.GetNext(data);
		}

		if(optLevel >= 2 && optimized)
		{
			this.OptimizeBlocks();
		}
	}
}