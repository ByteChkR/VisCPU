#include "ALLOC/Allocator.vhl"
#include "LinkedList.vhl"
#include "DEVS/STOREDRV.vhl"
#include "Partition.vhl"
#include "ExceptionHandler.vhl"
#include "PartitionTableCorruptedException.vhl"
#include "Console.vhl"

#define FORMAT_ON_CREATE 0

public class PartitionTable
{
	private uint m_Device;
	private uint m_List;
	public static PartitionTable(uint dev, Allocator alloc)
	{		
		this.m_Device = dev;
		uint lp = alloc.Allocate(size_of(LinkedList));
		LinkedList.new(lp, alloc);

		this.m_List = lp;
		this.Populate(alloc);
	}

	private static void Format(STOREDRV drv)
	{
		//Format Drive
		uint mod = drv.GetSize() / 10000;
		for(uint i = 0; i < drv.GetSize(); i++)
		{
			if((i % mod) == 0)
			{
				string fmtPerc = "% Completed (";
				Console.WriteNumber((i / mod) / 100);
				Console.Write(&fmtPerc, size_of(fmtPerc));
				Console.WriteNumber(i);
				Console.WriteChar('/');
				Console.WriteNumber(drv.GetSize());
				Console.WriteChar(')');
				Console.WriteChar('\n');
			}
			drv.Write(i, 0);
		}
	}
	
	public static void WriteDefault(STOREDRV drv)
	{
		if(FORMAT_ON_CREATE)
		{
			PartitionTable.Format();
		}

		drv.Write(0, 65535);
		uint dataLen = drv.GetSize() - 65538;
		drv.Write(65537, dataLen);

	}

	private uint FindNextHeader(uint current)
	{
		STOREDRV d = this.m_Device;
		uint pLen = d.Read(current);
		return current + pLen + 2; //Current + Partition Length + 2
	}

	private void Populate(Allocator a)
	{
		LinkedList lst = this.m_List;
		uint dp = this.m_Device;
		STOREDRV d = dp;
		uint sz = d.GetSize();
		uint cur = 0;
		while(cur < sz)
		{
			uint l = d.Read(cur);
			if(!l)
			{
				string errStr = "Can not read Partition Table. Restoring Table and formatting drive, the CPU will crash once repairs finished.";
				Console.WriteLine(&errStr, size_of(errStr));
				PartitionTable.WriteDefault(d);

				ExceptionHandler.Throw(PartitionTableCorruptedException());
				interrupt(1); //0 length partition
			}
			uint ptr = a.Allocate(size_of(Partition));
			Partition.new(ptr, dp, cur+1, l);
			lst.Add(ptr);
			cur = this.FindNextHeader(cur);
		}
	}

	public uint GetPartitionCount()
	{
		LinkedList l = this.m_List;
		uint c = l.Count();
		return c;
	}


	public uint GetPartition(uint num)
	{
		LinkedList l = this.m_List;
		uint c = l.Get(num);
		return c;
	}

	public uint GetDevice()
	{
		uint v = this.m_Device;
		return v;
	}
}