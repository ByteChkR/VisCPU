#include "../Partition.vhl"
#include "FileStream.vhl"
#include "FileTable.vhl"
#include "FileSystem.vhl"
#include "../../Console.vhl"

//Settings
#include <../../Settings/LoggingSettings.vhl>


private static string fs_Hint_NoSep = "NSEP";
private static string fs_Hint_NoNum = "NNUM";
private static string fs_Hint_TooShort = "SHRT";
private static string fs_Hint_MapIndexInvalid = "MIDX";
private static string fs_Hint_MapIndexUsed = "MUSE";
private static string fs_Hint_MapIndexUnmapped = "MUNM";
private static string fs_Hint_NoFs = "NOFS";
private static uint fs_PartitionMapping;

public static void fs_core_init()
{
	fs_PartitionMapping = malloc(10);
	for(uint i = 0; i < 10; i++)
	{
		fs_PartitionMapping[i] = 0;
	}
}

public static void fs_core_unload()
{
	if(fs_PartitionMapping)
	{
		free(fs_PartitionMapping);
		fs_PartitionMapping = 0;
	}
}

private static void fs_invalid_mapping(uint idx, string hint)
{
	string strInvalidMapping = "[FS] The Mapping is Invalid: ";
	kprint(&strInvalidMapping, size_of(strInvalidMapping));
	kprintn(idx);
	kprintc(0x20);
	string strHint = "(Hint: ";
	kprint(&strHint, size_of(strHint));
	kprint(hint, 4);
	kprintc(')');
	kprintc('\n');
	interrupt(1);
}

private static void fs_invalid_path(string p, uint l, string hint)
{
	string strInvalidPath = "[FS] The Path is Invalid: ";
	kprint(&strInvalidPath, size_of(strInvalidPath));
	kprint(p, l);
	kprintc(0x20);
	string strHint = "(Hint: ";
	kprint(&strHint, size_of(strHint));
	kprint(hint, 4);
	kprintc(')');
	kprintc('\n');
	interrupt(1);
}


public static void fs_unmap(uint mapIndex)
{
	if(mapIndex >= 10)
	{
		fs_invalid_mapping(mapIndex, &fs_Hint_MapIndexInvalid);
	}
	fs_PartitionMapping[mapIndex] = 0;
}

private static uint fs_has_mapped(uint mapIndex)
{
	if(mapIndex >= 10)
	{
		return 0;
	}
	uint v = fs_PartitionMapping[mapIndex];
	if(!v)
	{
		return 0;
	}
	return 1;
}

private static uint fs_map_get(uint mapIndex)
{
	if(mapIndex >= 10)
	{
		fs_invalid_mapping(mapIndex, &fs_Hint_MapIndexInvalid);
	}
	uint v = fs_PartitionMapping[mapIndex];
	if(!v)
	{
		fs_invalid_mapping(mapIndex, &fs_Hint_MapIndexUnmapped);
	}
	return v;
}

private static void fs_unmap(uint p)
{
	for(uint i = 0; i < 10; i++)
	{
		uint v = fs_PartitionMapping[i];
		if(v == p)
		{
			fs_PartitionMapping[i] = 0;
		}
	}
}

private static void fs_map(uint mapIndex, Partition p)
{
	if(mapIndex >= 10)
	{
		fs_invalid_mapping(mapIndex, &fs_Hint_MapIndexInvalid);
	}
	uint prevP = fs_PartitionMapping[mapIndex];
	if(prevP)
	{
		fs_invalid_mapping(mapIndex, &fs_Hint_MapIndexUsed);	
	}
	uint pp = p;
	fs_PartitionMapping[mapIndex] = pp;

}

public static uint fs_is_path(uint p, uint l)
{
	if(l < 3)
	{
		return 0;
	}
	uint dp = p[1];
	if(dp != ':')
	{
		return 0;
	}
	uint ln = p[0];
	ln -= '0';

	if(ln > 9)
	{
		return 0;
	}
	return 1;
}

private static uint fs_parse_drive_letter(uint p, uint l)
{
	if(l < 3)
	{
		fs_invalid_path(p, l, &fs_Hint_TooShort);
	}
	uint dp = p[1];
	if(dp != ':')
	{
		fs_invalid_path(p, l, &fs_Hint_NoSep);
	}
	uint ln = p[0];
	ln -= '0';

	if(ln > 9)
	{
		fs_invalid_path(p, l, &fs_Hint_NoNum);
	}
	return ln;
}

public static uint fs_resolve_fsys(uint p, uint l)
{
	uint num = fs_parse_drive_letter(p, l);
	Partition part = fs_map_get(num);
	uint fs = part.GetFileSystem();
	if(!fs)
	{
		fs_invalid_mapping(num, &fs_Hint_NoFs);	
	}

	return fs;
}

public static uint fs_open(uint p, uint l)
{
	FileSystem fs = fs_resolve_fsys(p, l);
	uint fstream = fs.Open(p+2, l-2);
	return fstream;
}

public static void fs_close(uint handle)
{
	if(FS_ENABLE_FILE_ACTION_LOGS)
	{
		string strCloseFile = "[FS] Closing File: ";
		kprint(&strCloseFile, size_of(strCloseFile));
		FileStream fs = handle;


		uint idx = fs.GetFileIndex();
		FileTable table = fs.GetFileTable();
		uint pl = table.GetEntryNameLength(idx);
		
		for(uint i = 0; i < pl; i++)
		{
			uint v = table.GetEntryName(idx, i);
			kprintc(v);
		}
		kprintc('\n');
	}
	free(handle);
}

public static uint fs_create(uint p, uint l)
{
	FileSystem fs = fs_resolve_fsys(p, l);
	uint fstream = fs.Create(p+2, l-2);
	return fstream;
}

public static void fs_delete(uint p, uint l)
{
	FileSystem fs = fs_resolve_fsys(p, l);
	fs.Delete(p+2, l-2);
}

public static uint fs_exists(uint p, uint l)
{
	FileSystem fs = fs_resolve_fsys(p, l);
	uint e = fs.Exists(p+2, l-2);
	return e;
}

public static uint fs_getsize(uint p, uint l)
{
	FileSystem fs = fs_resolve_fsys(p, l);
	uint fsize = fs.GetSize(p+2, l-2);
	return fsize;
}

public static void fs_info(uint mapIndex)
{
	Partition p = fs_map_get(mapIndex);
	FileSystem fs = p.GetFileSystem();
	fs.WriteInfo();
}

public static void fs_unload(uint mapIndex)
{
	if(!fs_has_mapped(mapIndex))
	{
		return;
	}
	uint pp = fs_map_get(mapIndex);
	Partition p = pp;
	FileSystem f = p.GetFileSystem();
	p.SetFileSystem(0);
	fs_unmap(pp);
	f.Unload();
}

public static void fs_init(uint mapIndex, uint p)
{

	uint fs = malloc(size_of(FileSystem));
	
	if(FS_ENABLE_LOGS)
	{
		string strInit1 = "[FS] Initializing File System(Partition: ";
		string strInit2 = ", FS: ";
		kprint(&strInit1, size_of(strInit1));
		kprintn(p);
		kprint(&strInit2, size_of(strInit2));
		kprintn(fs);
		kprintc(')');
		kprintc('\n');
	}

	FileSystem.new(fs, p);
	fs_map(mapIndex, p);
	Partition pp = p;
	pp.SetFileSystem(fs);
	return fs;
}

public static void f_write(FileStream handle, uint value)
{
	handle.Write(value);
}

public static void f_writebuf(FileStream handle, uint ptr, uint len)
{
	handle.WriteBuffer(ptr, len);
}

public static void f_readbuf(FileStream handle, uint ptr, uint len)
{
	handle.ReadBuffer(ptr, len);
}

public static uint f_read(FileStream handle)
{
	uint v = handle.Read();
	return v;
}

public static uint f_getsize(FileStream handle)
{
	uint v = handle.GetSize();
	return v;
}

public static void f_setsize(FileStream handle, uint size)
{
	handle.SetSize(size);
}

public static void f_setpos(FileStream handle, uint pos)
{
	handle.SetPosition(pos);
}

public static uint f_getpos(FileStream handle)
{
	uint p = handle.GetPosition();
	return p;
}

