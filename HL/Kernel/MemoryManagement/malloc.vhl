#include "../Console.vhl"
#inline "RawAllocator.vhl"

//Settings
#include <../Settings/MallocSettings.vhl>
#include <../Settings/LoggingSettings.vhl>



private static uint s_KernelAlloc;

private static void mallocinit()
{
	if(MALLOC_ENABLE_LOGS)
	{			
		string strInitMalloc = "[MALLOC] Initializing...";
		kprintl(&strInitMalloc, size_of(strInitMalloc));
	}
	RawAllocator a = RawAllocator(MALLOC_MEM_START, MALLOC_MEM_SIZE);
	a.SetOptimizationLevel(2);
	s_KernelAlloc = a;
}

public static void mallocclear()
{
	if(!s_KernelAlloc)
	{
		return;
	}
	if(MALLOC_ENABLE_LOGS)
	{			
		string strClearMalloc = "[MALLOC] Clearing...";
		kprintl(&strClearMalloc, size_of(strClearMalloc));
	}
	uint v = MALLOC_MEM_START;
	for(uint i = 0; i < MALLOC_MEM_SIZE; i++)
	{
		v[i] = 0;
	}
	s_KernelAlloc = 0;
}


public static void mallocinfo()
{
	string strInfo = "[MALLOC] Allocator Info: ";
	kprintl(&strInfo, size_of(strInfo));
	if(!s_KernelAlloc)
	{
		mallocinit();
	}

	RawAllocator a = s_KernelAlloc;
	a.WriteDebugData();
}

public static uint malloc(uint size)
{
	if(!s_KernelAlloc)
	{
		mallocinit();
	}

	RawAllocator a = s_KernelAlloc;
	uint p = a.Allocate(size);

	if(MALLOC_ENABLE_LOGS)
	{
		string strAllocSz = "[MALLOC] Allocating ";
		kprint(&strAllocSz, size_of(strAllocSz));
		kprintc('P');
		kprintc(':');
		kprintc(0x20);
		kprintn(p);
		kprintc(0x20);
		kprintc('S');
		kprintc(':');
		kprintnl(size);

	}

	return p;
}

public static void free(uint ptr)
{
	if(!s_KernelAlloc)
	{
		return;
	}

	RawAllocator a = s_KernelAlloc;

	if(MALLOC_ENABLE_LOGS)
	{
		string strAllocSz = "[MALLOC] Freeing Pointer: ";
		kprint(&strAllocSz, size_of(strAllocSz));
		kprintnl(ptr);
	}

	a.Free(ptr);
}