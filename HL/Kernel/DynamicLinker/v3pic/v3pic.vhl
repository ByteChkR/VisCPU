#include <../../Settings/LoggingSettings.vhl>
#include <../../MemoryManagement/malloc.vhl>
#include <../../DiskManagement/FileSystem/fs.vhl>
#include <../../Console.vhl>
#include <../../Utils/String.vhl>

private static uint v3pic_get_bin_start(uint libPtr)
{
	uint picStart = v3pic_get_pic_start(libPtr);
	uint picTableLen = picStart[2];
	return picStart + picTableLen+4;
}

//Returns the PIC Header Position
private static uint v3pic_get_pic_start(uint libPtr)
{
	uint picStart = v3pic_get_sym_entry(libPtr, v3pic_get_sym_entry_count(libPtr));
	return picStart;
}

//Returns the Number of Symbols in the Table of the Library
private static uint v3pic_get_sym_entry_count(uint libPtr)
{
	uint count = libPtr[0];
	return count;
}

//Get the Size of a Single Entry
private static uint v3pic_get_sym_entry_size(uint entryStart)
{
	uint nameSize = entryStart[0];
	uint totalSize = nameSize + 2;
	return totalSize;
}

//Get the Position of the Entry at index.
private static uint v3pic_get_sym_entry(uint libPtr, uint index)
{
	uint current = libPtr + 1;
	for(uint i = 0; i < index; i++)
	{
		uint sz = v3pic_get_sym_entry_size(current);
		current += sz;
	}
	return current;
}

//returns the pointer to the entry name
private static uint v3pic_get_sym_entry_name(uint entryPtr)
{
	uint nameStart = entryPtr+2;
	return nameStart;
}

//returns the size of the entry name
private static uint v3pic_get_sym_entry_name_size(uint entryPtr)
{
	uint nameStart = entryPtr[0];
	return nameStart;
}

//returns the call site of the entry(the address of the function)
private static uint v3pic_get_sym_entry_site(uint entryPtr)
{
	uint site = entryPtr[1];
	return site;
}


//Applies the correct offset for the current memory position
//Running this function multiple times will corrupt the table
private static void v3pic_patch_symtable(uint libPtr)
{
	uint binaryOffset = v3pic_get_bin_start(libPtr);
	uint symCount = v3pic_get_sym_entry_count(libPtr);

	if(V3PIC_ENABLE_LOGS)
	{
		string strPatchIdx = "[v3-pic] Patch List: ";
		kprint(&strPatchIdx, size_of(strPatchIdx));
		kprintnl(symCount);
	}


	uint symStart = libPtr + 1;
	for(uint i = 0; i < symCount; i++)
	{
		uint siteName = v3pic_get_sym_entry_name(symStart);
		uint siteNameSize = v3pic_get_sym_entry_name_size(symStart);
		
		
		uint site = v3pic_get_sym_entry_site(symStart);
		uint newSite = site + binaryOffset;
		if(V3PIC_ENABLE_LOGS)
		{
			string siteStr = "[v3-pic] Patching Site: ";
			kprint(&siteStr, size_of(siteStr));
			kprint(siteName, siteNameSize);
			kprintc('-');
			kprintc('>');
			kprintnl(newSite);
			
		}
		symStart[1] = newSite;
		symStart += v3pic_get_sym_entry_size(symStart);
	}
}

//Applies the correct offset for the current memory position
//Running this function multiple times will corrupt the binary
private static void v3pic_patch_pic(uint libPtr)
{
	uint picStart = v3pic_get_pic_start(libPtr);
	uint binaryStart = v3pic_get_bin_start(libPtr);
	uint picSymbolCount = v3pic_get_sym_entry_count(libPtr);
	uint version = picStart[1]; //Read Version Byte (V1 = 1)

	if(version != 2)
	{
		string strUnsupportedVersion = "Unsupported Binary Version: ";
		kprintl(&strUnsupportedVersion, size_of(strUnsupportedVersion));
		kprintnl(version);
		interrupt(1);
		return 0;
	}

	uint listLength = picStart[2]; //Read List Length

	uint picTableStart = picStart + 4;

	for(uint i = 0; i < listLength; i++)
	{
		uint valIndex = picTableStart[i];
		uint val = binaryStart[valIndex];


		uint newVal = val + binaryStart;
		
		binaryStart[valIndex] = newVal;
	}
}

public static void v3pic_unload(uint ptr)
{
	free(ptr);
}

public static uint v3pic_load(uint path, uint pathL)
{
	uint ex = fs_exists(path, pathL);
	if(!ex)
	{
		string fnf = "[v3-pic] File was not found: ";
		kprint(&fnf, size_of(fnf));
		kprintl(path, pathL);
		interrupt(1);
	}
	
	

	uint size = fs_getsize(path, pathL);
	uint ptr = malloc(size);

	if(V3PIC_ENABLE_LOGS)
	{
		string strPtrAddr = "[v3-pic] Loading at Address: ";
		kprint(&strPtrAddr, size_of(strPtrAddr));
		kprintnl(ptr);
	}

	uint file = fs_open(path, pathL);
	
	f_readbuf(file, ptr, size);
	fs_close(file);
	

	v3pic_patch_symtable(ptr);
	v3pic_patch_pic(ptr);

	return ptr;
}


//Resolves a Call Site inside an external Library
public static uint v3pic_resolve_call(uint lib, string funcName, uint funcNameLen)
{

	uint c = v3pic_get_sym_entry_count(lib);
	for(uint i = 0; i < c; i++)
	{
		uint eStart = v3pic_get_sym_entry(lib, i);
		uint eNStart = v3pic_get_sym_entry_name(eStart);
		uint eNLen = v3pic_get_sym_entry_name_size(eStart);
		if(str_cmp(eNStart, eNLen, funcName, funcNameLen))
		{
			uint site = v3pic_get_sym_entry_site(eStart);
			return site;
		}
	}

	string cre = "[DLR] Can not Find Site: ";
	kprint(&cre, size_of(cre));
	kprint(funcName, funcNameLen);
	kprintc('|')
	kprintnl(lib);
	interrupt(1); //Can not Resolve Call Site
}
